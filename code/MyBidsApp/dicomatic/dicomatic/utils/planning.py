"""
Conversion of raw study dictionaries into :class:`dicomatic.models.DownloadPlan`
instances.

The helper functions here centralise **all** rules that determine:

* Subject and session labels.
* Directory layout beneath the BIDS root.
* Archive filename selection (via :func:`dicomatic.utils.naming.build_bids_basename`).

Any module that needs a list of download targets should call
:func:`build_plans` instead of rolling its own logic.
"""

from __future__ import annotations

from pathlib import Path
from typing import Dict, List, Optional
import re

from dicomatic.models import DownloadPlan
from dicomatic.utils.bids_helpers import group_studies_by_bids
from dicomatic.utils.naming import build_bids_basename


# -----------------------------------------------------------------------------#
# Internal helpers                                                             #
# -----------------------------------------------------------------------------#
def _normalise_session_label(tok: str) -> str:
    """Return a canonical ``ses-XX`` label.

    Args:
        tok: Raw session token.  Accepts bare numbers (``"01"``),
            strings already in ``ses-##`` form, or arbitrary other tokens.

    Returns:
        ``ses-XX`` string.  Non-numeric tokens are given the ``ses-`` prefix
        verbatim, allowing descriptive labels such as ``ses-baseline``.
    """
    if tok.isdigit():
        return f"ses-{int(tok):02d}"
    if tok.startswith("ses-"):
        return tok
    return f"ses-{tok}"


def _normalise_subject_label(tok: str) -> str:
    """Return a canonical ``sub-XXX`` label.

    Args:
        tok: Raw subject token. Accepts bare numbers (``"01"``),
            strings already in ``sub-###`` form, or arbitrary other tokens.

    Returns:
        ``sub-XXX`` string. Non-numeric tokens are given the ``sub-`` prefix
        verbatim, allowing descriptive labels such as ``sub-control``.
    """
    clean = tok.strip()
    m = re.fullmatch(r"(?:sub-)?0*(\d+)", clean)
    if m:
        return f"sub-{int(m.group(1)):03d}"
    if clean.startswith("sub-"):
        return clean
    return f"sub-{clean}"


# -----------------------------------------------------------------------------#
# Public API                                                                    #
# -----------------------------------------------------------------------------#
def build_plans(  # noqa: C901 – orchestration unavoidably “busy”
    studies: List[Dict[str, str]],
    bids_root: Path,
    *,
    overrides: Optional[Dict[str, str]] = None,
    flatten: bool = False,
) -> List[DownloadPlan]:
    """Create :class:`DownloadPlan` objects from a flat *studies* list.

    Args:
        studies: Raw study dicts generated by the DICOM query parser.
        bids_root: Absolute path to the BIDS root or an alternate output
            directory.  All archives are placed relative to this folder.
        overrides: Optional mapping ``{"sub": "LABEL", "ses": "LABEL"}``
            that forces every plan to the given subject and session labels.
        flatten: When ``True`` omit the *ses-YY* directory if the subject
            has exactly one session.  The flag is ignored when *overrides*
            are supplied because single‐session knowledge is unavailable.

    Returns:
        List of fully populated :class:`DownloadPlan` objects in deterministic
        order (sorted by subject, session, and study date where applicable).
    """
    root = Path(bids_root).resolve()
    plans: List[DownloadPlan] = []

    # ------------------------------------------------------------------#
    # Fast-path: caller already stamped ``sub_label`` / ``ses_label``    #
    # ------------------------------------------------------------------#
    if (
        overrides is None
        and studies
        and all("sub_label" in s and "ses_label" in s for s in studies)
    ):
        # Count sessions per subject to decide on directory flattening
        ses_count: Dict[str, int] = {
            subj: len({st["ses_label"] for st in studies if st["sub_label"] == subj})
            for subj in {st["sub_label"] for st in studies}
        }

        for st in studies:
            sub = st["sub_label"]
            ses = st["ses_label"]

            dst_dir = root / sub
            # Keep session folder if flattening is disabled or multi-session
            if not (flatten and ses_count[sub] == 1):
                dst_dir = dst_dir / ses

            plans.append(
                DownloadPlan(
                    study=st,
                    path=dst_dir / build_bids_basename(st),
                    sub_label=sub,
                    ses_label=ses,
                )
            )
        return plans

    # ------------------------------------------------------------------#
    # Explicit overrides: every study forced into the same folder        #
    # ------------------------------------------------------------------#
    if overrides and overrides.get("sub") and overrides.get("ses"):
        sub_label = _normalise_subject_label(overrides["sub"])
        ses_label = _normalise_session_label(overrides["ses"])

        dst_dir = root / sub_label
        if not flatten:
            dst_dir = dst_dir / ses_label

        for st in studies:
            plans.append(
                DownloadPlan(
                    study=st,
                    path=dst_dir / build_bids_basename(st),
                    sub_label=sub_label,
                    ses_label=ses_label,
                )
            )
        return plans

    # ------------------------------------------------------------------#
    # Legacy path: derive labels automatically from PatientName, etc.    #
    # ------------------------------------------------------------------#
    grouped = group_studies_by_bids(studies)

    for sub, sessions in grouped.items():
        ses_count = len(sessions)  # needed for conditional flattening

        for ses, slist in sessions.items():
            for st in slist:
                dst_dir = root / sub
                if not (flatten and ses_count == 1):
                    dst_dir = dst_dir / ses

                plans.append(
                    DownloadPlan(
                        study=st,
                        path=dst_dir / build_bids_basename(st),
                        sub_label=sub,
                        ses_label=ses,
                    )
                )

    return plans
